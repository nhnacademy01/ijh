# 03 / 07

ctrl + shift + A => 검색창

ctrl + Alt + Shift + S => projectstructure

psvm : main함수
sout : 출력문

ctrl + alt + shift + 화살표위아래 : 콘솔창크기 위아래로 (네비게이션바도 가능)

지역변수, 매개변수, 인스턴스변수, 클래스변수< 이해필요

# 03 / 08

ctrl + alt + L -> 정렬
ctrl + alt + shift + L -> 정렬설정창 열기

shift + f6 -> class명 rename
ctrl + space = 오타난거 다시나옴

- psvm과 pvm의 차이.
코드를 적어보니 psvm에서는 객체를 생성하여야 void함수를 호출할 수 있고
pvm에서는 그냥 호출이 된다 왜 그럴까?

- 함수 생성할때 void test(){} 와 public static void test(){} 가 어떻게 다를까? 그냥 void로 함수를 생성하니 psvm에서 호출이 안된다

==> void 함수를 호출하려면 psvm에서 객체를 생성한 뒤 호출하여야 하고,
그냥 호출하려면 public static void로 함수를 만들어야 한다.
* 그리고 어떤 방법으로 사용하는것이 프로그램상 더 효율적인지 알아볼것

fori 치고 엔터치면 for문 양식 생성됨

[기업 면접시]
- 시간복잡도
*탐색 = log(n)
*정렬 = nlog(n)

- 점화식

* 함수와 메소드의 차이?

* break, return, continue 차이?

# 03 / 09

컨트롤 + b = 네비게이션

- 추상화
일반화와 특수화
 (날수있는것들)
=> 비행기, 새, 독수리 --> 일반화

분류화와 인스턴스
=> 개(분류), 스누피(인스턴스)
전체와 일부
=> 자동차(전체), 엔진(일부)

그룹화와 개별화
=> nhn아카데미수강생(그룹화) 기훈,종현(개별화)

개념을구체화하면 type

type을 구체화하면 class, interface

개념,타입,인터페이스,클래스

*dog이라는 class를 인스턴스화 시키면 스누피라는 객체가 된다
고로, 인스턴스(추상레벨높음) -> 인스턴스화 -> 객체(인스턴스화 됨)(추상화레벨낮음)

컨알엠 => 메소드분리

시그니처는 메소드명과 매개변수뿐이다. (리턴타입,접근제어자 아님)

* 행위적일때 일반화, 개와 같은경우 분류추상화

# 03 / 11

컨트롤쉬프트v : 이전복사했던 내용 복사할수있음

*패키지 사용법
-분류추상화, 일반화(?)
* cd,dvd 실습 복습

컨쉬 화살표 -> 스코프 단위 이동

** 컴퓨터에는 dvd드라이버가 있다 -> 컴퓨터야 내cd를 플레이 해줘 ->
컴퓨터가 플레이cd를 실행시키려면 play할수있는 play메소드가 있어야함 ->
컴퓨터는 직접 실행할 수 없다 -> 컴퓨터 내부에 (객체화된)dvd드라이버라는 속성에 위임을한다 -> dvd는 기본적으로 dvd만 play할 수 있다 하지만 cd드라이버를 상속받았기 때문에 cd드라이버의 기능을 사용할 수 있다(호출할수있다) -> cd play

*합성(구성)과 상속
has a(합성) : 가지고 있다 ex) 컴퓨터(class)는 dvd드라이버(멤버(인스턴스)변수)를 가지고 있다.
is a(상속) : 이다 ex) dvd드라이버는 cd드라이버이다?

// class 내에 아무것도 만들지 않아도, 컴파일러가 자동으로 super() 메소드와 같이 기본생성자를 만들어 준다

*Final
- 메서드에 사용하면 오버라이딩을 할 수 없다

*다형성

*오버로딩, 오버라이딩 차이

# 03 / 14

- shallow copy와 deep Copy중

Q1. shallow copy를 쓰지않는 이유를 swap같은 경우 복사를 했는데도 복사가 안되서 안쓰는줄 알고 이해하고 있었는데 수업 내용을 들으니 반대로 shallow copy로 인해 주소자원을 공유하기 때문에 값들이 같이 바뀌어서 안쓰는거라고 해서 조금 헷갈리는 것 같습니다.

A1. 네 복사가 안되는 것이 아니라 공유가되는 것이 맞습니다.
A1.하위 속성 중 참조형은 완벽한 복사가 안되고 공유해서 사용하기 때문에 shallow copy가 문제가 생깁니다.

-> 그렇다면 shallow copy는 자원을 공유하는데 왜 swap에선 복사가 안되는것인가?

* StringBuild 와 String Buffer 차이

StringBuild 는 멀티쓰레드 환경에서 취약하고,
String Buffer는 syncnorized로 동기화를 하기 때문에 속도가 느리지만 멀티쓰레드 환경에서 안전하다 

* Boxing과 UnBoxing(편의를 위해 java에서 제공하는 기능)
int -> 인티저 [ 박싱(객체로 감싸면) ]
인티저 - > int [ 언박싱(객체를 풀어내면) ]박스를 풀어서 실제값으로 했다.

# 03 / 15 
ofInstance (?)

- 굳이 try / catch를 써서 예외처리를 할 필요가 있나? 그냥 if문 걸어서 sout 출력하는게 코드가 더 줄이 짧지 않을까?

# 03 / 16
TODO, FIXME 구문

* set, map // 해야됨

# 03 / 17
- 3종세트 wildcard
upper, lower, 일반

컨 + h -> 상속구조

메소드에 final이 붙어있으면 재정의불가.
class에 final이 붙어있으면 상속불가
변수에 final이 붙어있으면 재할당불가

인스턴스 변수 == 필드 (?)

# 03 / 18 
- map, flatMap 차이
stream, lambda 마스터